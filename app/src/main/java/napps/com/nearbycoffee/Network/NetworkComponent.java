package napps.com.nearbycoffee.Network;

import javax.inject.Singleton;

import dagger.Component;
import napps.com.nearbycoffee.AppComponent;
import napps.com.nearbycoffee.AppModule;
import napps.com.nearbycoffee.MainActivity;
import retrofit2.Retrofit;

/**
 * Created by "nithesh" on 7/16/2017.
 */

/*
This is an interface that connects the provider and the consumer. Here we have to mention in what all classes we are using the dagger objects.
i.e where all we are using @Inject keyword to create objects we will call inject(activity/service/fragment) in those classes. So we have to have methods
defined before we call them. So we are defining those methods here.


 */
@Singleton
//The two models have been mentioned here. It is because in case Network Component is initialized somewhere, it calls all the provides methods
//to create instances in dependency graph. If we observe NetworkModule creates
// PlacesAPIInterface instance            which uses
// Retrofit instance                    which uses
// Gson and OkhttpClient instance       which uses
//Cache instancue                       which uses
//Application instance                  but
//To create application instance there is no provides method in network module. So we will use
//AppModule which has provides method for application instance.
// So the dependency graph is such that
//      PlacesAPIInterface    <-  Retrofit    <-  Gson, OkHttpClient  <-  Cache   <-  Application (Created during instantiation of application creation through the constructor)


//This Component class has dependency on AppComponent because NetworkModule needs Application instance. The application instance is generated by
//AppComponent which tells Dagger that first create App Component class which will create an application instance and then create this instance
@Component(modules = {AppModule.class, NetworkModule.class}, dependencies = {AppComponent.class})
public interface NetworkComponent {

    //Now that we have separated NetworkAPIModule and made that as sub component, this becomes the main component.
    //So this does not take any inject methods directly. This in turn produce the instances that are required for sub component
    //We do not need to specify anything. This is just like a contract that this NetworkComponent is a parent component
    //and it's child component will take care of injecting activities/services/fragments
    Retrofit getRetrofit();

}
