package napps.com.nearbycoffee.Network;

import javax.inject.Singleton;

import dagger.Component;
import napps.com.nearbycoffee.AppComponent;
import napps.com.nearbycoffee.AppModule;
import napps.com.nearbycoffee.MainActivity;
import retrofit2.Retrofit;

/**
 * Created by "nithesh" on 7/16/2017.
 */

/*
This is an interface that connects the provider and the consumer. Here we have to mention in what all classes we are using the dagger objects.
i.e where all we are using @Inject keyword to create objects we will call inject(activity/service/fragment) in those classes. So we have to have methods
defined before we call them. So we are defining those methods here.


 */
//The two models have been mentioned here. It is because in case Network Component is initialized somewhere, it calls all the provides methods
//to create instances in dependency graph. If we observe NetworkModule creates
// PlacesAPIInterface instance            which uses
// Retrofit instance                    which uses
// Gson and OkhttpClient instance       which uses
//Cache instancue                       which uses
//Application instance                  but
//To create application instance there is no provides method in network module. So we will use
//AppModule which has provides method for application instance.
// So the dependency graph is such that
//      PlacesAPIInterface    <-  Retrofit    <-  Gson, OkHttpClient  <-  Cache   <-  Application (Created during instantiation of application creation through the constructor)


//This Component class has dependency on AppComponent because NetworkModule needs Application instance. The application instance is generated by
//AppComponent which tells Dagger that first create App Component class which will create an application instance and then create this instance
@Singleton
@Component(modules = {NetworkModule.class})
public interface NetworkComponent {

    //Now that we have separated NetworkAPIModule and made that kind of sub component, this becomes the main component.
    //So this does not take any inject methods directly. This in turn produce the instances that are required for sub component
    //We do not need to specify anything. This is just like a contract that this NetworkComponent is a parent component
    //and it's child component will take care of injecting activities/services/fragments

    Retrofit getRetrofit();

    //Regarding the list of modules that can be added is related which all methods can be generated from this component
    //If we wanted to generate the instances like below
    //Retrofit getRetrofit()
    //BaseApplication getBaseApplication()
    //Then we needed @Component(modules = {NetworkModule.class, AppModule.class}) because getBaseApplication is obtained from AppModule
    //Since we are not doing that we don't need that

    //What modules to include is explained below
    //    @Singleton
    //    @Component(modules={AppModule.class, NetModule.class})
    //    public interface NetComponent {
    //        void inject(MainActivity activity);
    //        // void inject(MyFragment fragment);
    //        // void inject(MyService service);
    //    }
    //  This is a component which is instantiated in MainActivity. After instantiating we use two fields using @Inject
    //    @Inject MyTwitterApiClient mTwitterApiClient;
    //    @Inject SharedPreferences sharedPreferences;
    //  Now MyTwitterApiClient is available in Netmodule.class which is connected to Netcomponent so it's fine.
    //  SharedPreferences is the reason why we included Appmodule.class in component because it is present in AppModule.
    //  So the methods inside a component are optional. We have to include the modules related to all the @Inject fields in modules list.


}
